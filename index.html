<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FutMaster ‚Äî v3.3 (Racha)</title>
<style>
:root{
  --bg1:#c9a85a; --bg2:#b8925a; --panel:#0b0b0b; --gold:#b8860b; --muted:#4b3d2a; --text-dark:#111; --card:#f3e7cf;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--text-dark)}
.container{max-width:1200px;margin:18px auto;padding:16px;border-radius:12px;background:linear-gradient(180deg, rgba(0,0,0,0.03), rgba(0,0,0,0.02));box-shadow:0 8px 30px rgba(0,0,0,0.08)}
.header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
.title{font-size:20px;font-weight:800;color:var(--panel);letter-spacing:0.6px}
.subtitle{color:var(--muted);font-size:13px}
.top-controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px;align-items:center}
input[type="text"], input[type="search"]{padding:10px;border-radius:8px;border:1px solid rgba(0,0,0,0.08);min-width:220px}
button{background:var(--panel);color:var(--gold);border:2px solid var(--gold);padding:9px 12px;border-radius:8px;font-weight:700;cursor:pointer}
.btn-ghost{background:transparent;border:1px solid rgba(0,0,0,0.06);color:var(--panel);padding:8px}
.small{font-size:13px;color:var(--muted)}
.layout{display:grid;grid-template-columns: 1fr 360px;gap:16px}
@media (max-width:980px){ .layout{grid-template-columns:1fr} }
.left-panel{display:flex;flex-direction:column;gap:12px}
.panel{background:var(--card);padding:12px;border-radius:10px;border:1px solid rgba(0,0,0,0.06)}
.queue-list{max-height:420px;overflow:auto;margin-top:8px;display:flex;flex-direction:column;gap:8px}
.row{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;background:linear-gradient(90deg,rgba(255,255,255,0.6),rgba(255,255,255,0.95));border:1px solid rgba(0,0,0,0.04)}
.pos{width:40px;color:var(--muted);text-align:center}
.name{flex:1;font-weight:700;color:var(--text-dark)}
.actions{display:flex;gap:6px}
.teams{display:flex;flex-direction:column;gap:12px}
.team-card{flex:1;padding:12px;border-radius:10px;background:linear-gradient(180deg,rgba(255,255,255,0.98),rgba(255,255,255,0.96));border:2px solid rgba(0,0,0,0.04)}
.team-title{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;font-weight:800;color:var(--panel)}
.team-heading{font-size:16px}
.team-players{display:flex;flex-direction:column;gap:6px;min-height:60px;padding:6px;border-radius:6px;border:1px dashed rgba(0,0,0,0.04)}
.player-item{display:flex;align-items:center;gap:8px;padding:6px;border-radius:8px;background:linear-gradient(90deg, rgba(234,223,208,0.6), rgba(234,223,208,0.85));border:1px solid rgba(0,0,0,0.03)}
.player-role{width:28px;color:var(--muted);text-align:center}
.player-name{flex:1;font-weight:800;color:var(--panel)}
.timer-bottom { margin-top:20px; text-align:center; padding:14px; background: linear-gradient(180deg, rgba(0,0,0,0.05), rgba(0,0,0,0.03)); border-radius:12px; border:2px solid rgba(0,0,0,0.04); }
.timer-big { font-size:72px; font-weight:900; color:#000; text-shadow: 0 0 0 #000, 0 0 10px var(--gold); margin:6px 0; -webkit-text-stroke:2px #b8860b; }
.tiny{padding:6px 8px;border-radius:8px;font-size:13px;background:transparent;border:1px solid rgba(0,0,0,0.04)}
.badge-incomplete{color:var(--panel);font-weight:700;background:linear-gradient(90deg,#fff,#f3e7cf);padding:2px 6px;border-radius:6px;border:1px solid rgba(0,0,0,0.05)}
.footer{display:flex;flex-direction:column;align-items:center;gap:6px;margin-top:10px;color:var(--muted)}
.drag-over { outline: 3px dashed rgba(0,0,0,0.2); }

/* status colors - estilo est√°dio simplificado */
.team-heading.status-playing-1 { font-weight:900; color: #0b6623; } /* verde */
.team-heading.status-playing-2 { font-weight:900; color: #1e90ff; } /* azul */
.team-heading.status-next { font-weight:900; color: #e6b800; } /* amarelo */
.team-heading.status-waiting { font-weight:700; color: #6b6b6b; } /* gray */
.team-status { font-weight:800; margin-left:6px; }

@media (max-width:600px){
  .timer-big{font-size:44px}
  input[type="text"]{min-width:140px}
  .container{padding:12px;margin:8px}
}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div>
      <div class="title">FutMaster ‚Äî Racha</div>
      <div class="subtitle">v3.3 ‚Äî Online / Offline</div>
    </div>
    <div class="small">Voc√™: Jos√©</div>
  </div>

  <div class="top-controls">
    <input id="inputPlayer" placeholder="Nome do jogador e Enter" />
    <button id="btnAdd">Adicionar (ir para final)</button>
    <button id="btnFormTeams" class="btn-ghost">Sortear 10 primeiros e formar A/B</button>
    <button id="btnGroup5" class="btn-ghost">Formar restantes em times (5 + incompletos)</button>
    <button id="btnMakeNext" class="btn-ghost">Puxar pr√≥ximo time (5)</button>
    <button id="btnReset" class="btn-ghost">Nova Noite (limpar)</button>
    <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
      <label class="small"><input type="checkbox" id="chkClearOnLoad"> Limpar pagamentos ao abrir</label>
    </div>
  </div>

  <div class="layout">
    <div class="left-panel">
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:800">Fila de Jogadores (ordem de chegada)</div>
          <div class="small">Total: <span id="countQueue">0</span></div>
        </div>
        <div class="queue-list" id="queueList" ondragover="allowDrop(event)" ondrop="onDropToQueue(event)"></div>
        <div style="display:flex;gap:8px;margin-top:10px">
          <button id="btnShuffle" class="tiny">Embaralhar</button>
          <button id="btnExport" class="tiny">Exportar (texto)</button>
          <button id="btnImport" class="tiny">Importar (colar)</button>
        </div>
      </div>

      <div class="panel teams">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:900">Times em Ordem (A ‚Üí Z)</div>
          <div class="small">A√ß√µes: mover time, puxar pr√≥ximos, registrar derrota</div>
        </div>

        <div id="teamsContainer"></div>

        <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
          <button id="btnKeepWinner" class="tiny">Manter vencedor (padr√£o)</button>
          <div style="margin-left:auto" class="small">Times: <span id="countTeams">0</span></div>
        </div>
      </div>
    </div>

    <div class="right-panel">
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:900">Painel de Pagamentos</div>
          <div style="display:flex;gap:6px">
            <button id="btnClearPayments" class="tiny">Limpar pagamentos</button>
            <button id="btnExportPayments" class="tiny">Exportar</button>
          </div>
        </div>
        <div class="payments-list" id="paymentsList"></div>
        <div style="margin-top:10px" class="small">Marque quem j√° pagou a noite.</div>
      </div>
    </div>
  </div>

  <div class="timer-bottom">
    <div style="font-weight:800">Cron√¥metro ‚Äî Partida (7 minutos)</div>
    <div class="timer-big" id="timerDisplay">07:00</div>
    <div style="display:flex;justify-content:center;gap:8px;margin-top:8px">
      <button id="startBtn" class="tiny">Iniciar</button>
      <button id="pauseBtn" class="tiny">Pausar</button>
      <button id="resetBtnTimer" class="tiny">Resetar</button>
      <label style="align-self:center;margin-left:8px"><input type="checkbox" id="chkSound" checked> Som</label>
    </div>
    <div style="margin-top:10px">
      <!-- Test button will now play ONLY the licensed final whistle -->
      <button id="btnTestWhistle" style="background:var(--gold);color:#000;border:2px solid #000;padding:10px 14px;border-radius:8px;font-weight:800">Testar Apito</button>
      <!-- New final whistle controls -->
      <button id="btnFinalWhistle" style="background:#000;color:#fff;border:2px solid #000;padding:10px 14px;border-radius:8px;font-weight:800;margin-left:8px">Apito Final</button>
      <label class="small" style="margin-left:8px"><input type="checkbox" id="chkFinalWhistle" checked> Usar apito final ao terminar</label>

      <!-- Licensed final whistle (Drive download link). This audio element is the single source of the final whistle sound used by Testar Apito and at timer end. -->
      <audio id="finalWhistle" src="https://drive.google.com/uc?export=download&id=1W6ap8YEj9Zn36qIMb6Y_pGaC20OQd6pc" preload="auto" playsinline></audio>

      <div class="small" style="margin-top:6px;color:var(--muted)">Toque para ativar o som no navegador e testar o apito (recomendado antes do jogo).</div>
    </div>
  </div>

  <div class="footer">
    <div class="small">Apito de est√°dio embutido. Mantenha a aba ativa no celular para garantir reprodu√ß√£o.</div>
    <div class="small">Salvo automaticamente no navegador (localStorage) ‚Äî e sincronizado com Firebase se online.</div>
    <div style="font-weight:700;color:var(--gold)">FutMaster v3.3</div>
  </div>
</div>

<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

<script>
/* =========================
   CONFIG
   ========================= */
// Toggle Firebase synchronization. Set to true to enable remote sync via Firebase RTDB.
const ENABLE_FIREBASE = true; // enabled

/* =========================
   FIREBASE CONFIG (SEU)
   ========================= */
const firebaseConfig = {
  apiKey: "AIzaSyAuKyiDOpKsq11iO0c7v8NvQYqVdbZr4Ko",
  authDomain: "futuriasmaster.firebaseapp.com",
  databaseURL: "https://uriasfutmaster2-default-rtdb.firebaseio.com/",
  projectId: "futuriasmaster",
  storageBucket: "futuriasmaster.firebasestorage.app",
  messagingSenderId: "698635901166",
  appId: "1:698635901166:web:670975316797b14eb07bff",
  measurementId: "G-XLTG46ZKZP"
};

let firebaseEnabled = false;
let dbRef = null;

/* ===== Sync / debounce / lock variables ===== */
let _pushTimeout = null;
const PUSH_DEBOUNCE_MS = 800;

// Lock / presence
const LOCK_TTL_MS = 7000;         // lock expires if not refreshed
const LOCK_REFRESH_MS = 3000;     // refresh lock interval
const INACTIVITY_TO_RELEASE_MS = 4000; // release after inactivity

let clientId = (Math.random().toString(36).slice(2) + Date.now().toString(36)); // unique per client
window.futpro = window.futpro || {};
window.futpro.clientId = clientId;

let lockRef = null;
let currentLock = null;
let lockRefreshTimer = null;
let stopEditingTimer = null;
let isEditing = false;
let lastRemoteUpdatedAt = null;
let lastRemoteState = null;

/* =========================
   FIREBASE INIT & SYNC
   ========================= */
function schedulePushStateToFirebase() {
  if (!firebaseEnabled || !dbRef) return;
  if (_pushTimeout) clearTimeout(_pushTimeout);
  _pushTimeout = setTimeout(() => {
    try {
      if (canPushToFirebase()) {
        // use child('state') to avoid overwriting other children
        dbRef.child('state').set(state)
          .then(()=> console.info('Pushed state to Firebase (debounced)'))
          .catch(e=> console.warn('Push error (debounced)', e));
      } else {
        console.info('Push blocked by lock owned by', currentLock && currentLock.owner);
      }
    }
    catch (e) { console.warn('pushStateToFirebase error', e); }
    _pushTimeout = null;
  }, PUSH_DEBOUNCE_MS);
}

function pushStateToFirebaseImmediate() {
  if (!firebaseEnabled || !dbRef) return;
  try {
    if (canPushToFirebase()) {
      dbRef.child('state').set(state)
        .then(()=> console.info('Pushed state to Firebase (immediate)'))
        .catch(e=> console.warn('Push error (immediate)', e));
    } else {
      console.info('Immediate push blocked by lock owned by', currentLock && currentLock.owner);
    }
  } catch(e){ console.warn(e); }
}

function pushStateToFirebase(){
  if(!firebaseEnabled || !dbRef) return;
  try{
    dbRef.child('state').set(state)
      .then(()=> console.info('Pushed state to Firebase'))
      .catch(e=> console.warn('Push error', e));
  }catch(e){ console.warn(e); }
}

function canPushToFirebase(){
  if(!firebaseEnabled || !dbRef) return false;
  if(!currentLock) return true;
  if(currentLock.owner === clientId) return true;
  if(currentLock.expiresAt && currentLock.expiresAt < Date.now()) return true;
  return false;
}

function initLockRef(){
  if(!firebaseEnabled || !dbRef) return;
  lockRef = dbRef.child('lock');
  lockRef.on('value', snap => {
    currentLock = snap.val();
  });
}

function tryAcquireLock(){
  if(!firebaseEnabled || !lockRef) return Promise.resolve(false);
  const now = Date.now();
  return lockRef.transaction(curr => {
    const expires = (curr && curr.expiresAt) ? curr.expiresAt : 0;
    if(!curr || expires < now){
      return { owner: clientId, ts: now, expiresAt: now + LOCK_TTL_MS };
    }
    return;
  }).then(result => {
    return result && result.committed && result.snapshot && result.snapshot.val() && result.snapshot.val().owner === clientId;
  }).catch(e => { console.warn('lock tx err', e); return false; });
}

function refreshLock(){
  if(!firebaseEnabled || !lockRef) return;
  if(currentLock && currentLock.owner === clientId){
    const now = Date.now();
    lockRef.update({ expiresAt: now + LOCK_TTL_MS, ts: now }).catch(e=>console.warn('refreshLock err', e));
  }
}

function releaseLock(){
  if(!firebaseEnabled || !lockRef) return;
  lockRef.transaction(curr => {
    if(curr && curr.owner === clientId){
      return null;
    }
    return;
  }).then(()=>{ currentLock = null; }).catch(e=>console.warn('release lock err', e));
}

function startEditing(){
  if(isEditing){
    if(stopEditingTimer) clearTimeout(stopEditingTimer);
    stopEditingTimer = setTimeout(stopEditing, INACTIVITY_TO_RELEASE_MS);
    return;
  }
  isEditing = true;
  tryAcquireLock().then(acquired=>{
    if(!acquired){
      console.info('N√£o conseguiu lock (outro cliente pode estar editando). Seus pushes ser√£o bloqueados at√© obter lock.');
    } else {
      console.info('Lock adquirido por', clientId);
    }
    if(lockRefreshTimer) clearInterval(lockRefreshTimer);
    lockRefreshTimer = setInterval(refreshLock, LOCK_REFRESH_MS);
    if(stopEditingTimer) clearTimeout(stopEditingTimer);
    stopEditingTimer = setTimeout(stopEditing, INACTIVITY_TO_RELEASE_MS);
  });
}

function stopEditing(){
  isEditing = false;
  if(stopEditingTimer){ clearTimeout(stopEditingTimer); stopEditingTimer = null; }
  if(lockRefreshTimer){ clearInterval(lockRefreshTimer); lockRefreshTimer = null; }
  releaseLock();
}

function enableFirebaseIfConfigured(){
  try{
    if(!ENABLE_FIREBASE) return false;
    if(!firebaseConfig || !firebaseConfig.databaseURL) return false;
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    dbRef = db.ref('futpro_rotacao');
    firebaseEnabled = true;

    // initial load: merge based on updatedAt timestamp
    dbRef.once('value').then(snap => {
      const remote = snap.val();
      if(remote && remote.state){
        const remoteState = remote.state;
        lastRemoteUpdatedAt = remoteState.updatedAt || null;
        lastRemoteState = remoteState;

        if(!state.updatedAt || (remoteState.updatedAt && remoteState.updatedAt > state.updatedAt)){
          state = {...state, ...remoteState};
          // normalize remote merge to avoid duplicates
          normalizeState();
          console.info('Firebase: applied remote state');
          renderAll();
        } else {
          console.info('Firebase: kept local state (newer)');
          // send local to remote if allowed
          schedulePushStateToFirebase();
        }
      } else {
        // no remote state -> push local
        pushStateToFirebaseImmediate();
      }
    }).catch(e=>console.warn('firebase once error', e));

    // listen for remote changes and apply only if remote is newer
    dbRef.on('value', snap=>{
      if (firebasePause) return;
      const remote = snap.val();
      if(remote && remote.state){
        const remoteState = remote.state;
        lastRemoteUpdatedAt = remoteState.updatedAt || null;
        lastRemoteState = remoteState;
        if(!state.updatedAt || (remoteState.updatedAt && remoteState.updatedAt > state.updatedAt)){
          state = {...state, ...remoteState};
          normalizeState();
          console.info('Firebase: merged remote update');
          renderAll();
        }
      }
    });

    initLockRef();
    return true;
  }catch(e){ console.warn('Firebase init error', e); return false; }
}

/* =========================
   APP STATE & STORAGE
   ========================= */
const KEY = 'futpro_v3_3_state';
let state = { playersQueue: [], teams: [], payments: {}, clearPaymentsOnLoad: false, timerSeconds: 7*60, soundOn: true, updatedAt: Date.now() };
let firebasePause = false;

function save(){
  // normalize before saving to avoid duplicates
  normalizeState();
  state.updatedAt = Date.now(); localStorage.setItem(KEY, JSON.stringify(state)); if(firebaseEnabled) schedulePushStateToFirebase();
}
function load(){ const v=localStorage.getItem(KEY); if(v){ try{ const p=JSON.parse(v); state = {...state, ...p}; }catch(e){console.warn(e);} } if(state.clearPaymentsOnLoad) state.payments={}; }

// normalize state: remove duplicates ensuring each player appears once (teams preferred)
function normalizeState(){
  const seen = new Set();
  state.teams = (state.teams || []).map(team => {
    return (team || []).filter(name => {
      if(!name) return false;
      if(seen.has(name)) return false;
      seen.add(name);
      return true;
    });
  }).filter(team => team.length > 0);

  const newQueue = [];
  (state.playersQueue || []).forEach(name => {
    if(!name) return;
    if(seen.has(name)) return; // already in a team
    if(newQueue.indexOf(name) !== -1) return; // dedupe in queue
    newQueue.push(name);
    seen.add(name);
  });
  state.playersQueue = newQueue;

  state.payments = state.payments || {};
  uniquePlayers().forEach(p => { state.payments[p] = state.payments[p] || false; });
}

function formatTime(s){ const m=Math.floor(s/60).toString().padStart(2,'0'); const sec=(s%60).toString().padStart(2,'0'); return `${m}:${sec}`; }
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }

// DOM refs
const queueList = document.getElementById('queueList');
const countQueue = document.getElementById('countQueue');
const teamsContainer = document.getElementById('teamsContainer');
const countTeams = document.getElementById('countTeams');
const paymentsList = document.getElementById('paymentsList');
const timerDisplay = document.getElementById('timerDisplay');
const chkClearOnLoad = document.getElementById('chkClearOnLoad');
const chkSound = document.getElementById('chkSound');
const inputPlayer = document.getElementById('inputPlayer');
const btnAdd = document.getElementById('btnAdd');

/* =========================
   RENDER FUNCTIONS
   ========================= */
function renderAll(){ renderQueue(); renderTeams(); renderPayments(); timerDisplay.textContent = formatTime(state.timerSeconds); chkClearOnLoad.checked = !!state.clearPaymentsOnLoad; chkSound.checked = !!state.soundOn; }

function renderQueue(){
  queueList.innerHTML='';
  state.playersQueue.forEach((name, idx)=>{
    const div = document.createElement('div'); div.className='row';
    div.draggable = true;
    div.dataset.origin = 'queue'; div.dataset.idx = idx;
    div.innerHTML = `<div class="pos">${idx+1}</div><div class="name">${escape(name)}</div><div class="actions">
      <button class="tiny edit-queue" data-idx="${idx}">‚úèÔ∏è</button>
      <button class="tiny up-queue" data-idx="${idx}">üîº</button>
      <button class="tiny down-queue" data-idx="${idx}">üîΩ</button>
      <button class="tiny move-to-team" data-idx="${idx}">‚Ü™Ô∏è Mover</button>
      <button class="tiny remove-queue" data-idx="${idx}">üóëÔ∏è</button>
    </div>`;
    div.addEventListener('dragstart', (e)=> onDragStart(e, {type:'queue', idx}));
    queueList.appendChild(div);
  });
  countQueue.textContent = state.playersQueue.length;
}

function renderTeams(){
  teamsContainer.innerHTML='';
  state.teams.forEach((team, tIndex)=>{
    const teamLabel = String.fromCharCode(65 + tIndex);
    let statusLabel = '';
    let statusClass = '';
    if(tIndex === 0){ statusLabel = 'Jogando'; statusClass = 'status-playing-1'; }
    else if(tIndex === 1){ statusLabel = 'Jogando'; statusClass = 'status-playing-2'; }
    else if(tIndex === 2){ statusLabel = 'Pr√≥ximo'; statusClass = 'status-next'; }
    else { statusLabel = 'Aguardando'; statusClass = 'status-waiting'; }
    const card = document.createElement('div'); card.className='team-card';
    const playersHtml = team.map((p, idx)=> `<div class="player-item" draggable="true" data-origin="team" data-team="${tIndex}" data-idx="${idx}" >
      <div class="player-role">${idx+1}</div><div class="player-name">${escape(p)}</div>
      <div style="display:flex;gap:6px">
        <button class="tiny edit-team" data-team="${tIndex}" data-idx="${idx}">‚úèÔ∏è</button>
        <button class="tiny move-up-team" data-team="${tIndex}" data-idx="${idx}">üîº</button>
        <button class="tiny move-down-team" data-team="${tIndex}" data-idx="${idx}">üîΩ</button>
        <button class="tiny move-player" data-team="${tIndex}" data-idx="${idx}">‚ÜîÔ∏è Mover</button>
        <button class="tiny remove-team-player" data-team="${tIndex}" data-idx="${idx}">‚§µÔ∏è Enviar √† fila</button>
      </div></div>`).join('') || '<div class="small">Vazio</div>';
    card.innerHTML = `<div class="team-title"><div class="team-heading ${statusClass}">Time ${teamLabel} ‚Äî <span class="team-status">${statusLabel}</span></div><div class="small">${team.length} jogadores</div></div>
      <div class="team-players">${playersHtml}</div>
      <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
        <button class="tiny btn-pull-next" data-team="${tIndex}">Puxar pr√≥ximo (5)</button>
        <button class="tiny btn-loser" data-team="${tIndex}">Time ${teamLabel} perdeu</button>
        <button class="tiny btn-move-up-card" data-team="${tIndex}">‚¨ÜÔ∏è Subir time</button>
        <button class="tiny btn-move-down-card" data-team="${tIndex}">‚¨áÔ∏è Descer time</button>
        <button class="tiny btn-move-to-pos" data-team="${tIndex}">‚ÜïÔ∏è Mover para posi√ß√£o</button>
      </div>`;
    teamsContainer.appendChild(card);
  });

  document.querySelectorAll('.player-item').forEach(el=>{
    el.addEventListener('dragstart', (e)=>{
      const origin = el.dataset.origin; const team = el.dataset.team; const idx = el.dataset.idx;
      onDragStart(e, {type:'team', team: Number(team), idx: Number(idx)});
    });
  });

  countTeams.textContent = state.teams.length;
}

/* util */
function escape(s=''){ return (''+s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function escapeAttr(s=''){ return (''+s).replace(/\"/g,'&quot;'); }
function uniquePlayers(){ const s=new Set(); state.playersQueue.forEach(p=>s.add(p)); state.teams.flat().forEach(p=>s.add(p)); return Array.from(s); }

/* ========== DRAG & DROP ========== */
let currentDrag = null;
function onDragStart(e, info){ currentDrag = info; try{ e.dataTransfer.setData('text/plain', JSON.stringify(info)); }catch(err){} }
function allowDrop(e){ e.preventDefault(); const el = e.currentTarget; el.classList.add('drag-over'); }
function clearDragOver(){ document.querySelectorAll('.team-players, #queueList').forEach(el=>el.classList.remove('drag-over')); }
function onDropToTeam(e, teamIndex){ e.preventDefault(); clearDragOver(); const data = currentDrag; if(!data) return; performMove(data, {type:'team', team:teamIndex}); currentDrag=null; renderAll(); }
function onDropToQueue(e){ e.preventDefault(); clearDragOver(); const data = currentDrag; if(!data) return; performMove(data, {type:'queue'}); currentDrag=null; renderAll(); }

function performMove(src, target){
  let name = null;
  if(src.type==='queue'){
    name = state.playersQueue[src.idx];
    if(typeof src.idx === 'number') state.playersQueue.splice(src.idx,1);
  } else if(src.type==='team'){
    name = state.teams[src.team][src.idx];
    state.teams[src.team].splice(src.idx,1);
  }
  if(!name) return;
  if(target.type==='queue'){ state.playersQueue.push(name); }
  else if(target.type==='team'){ state.teams[target.team] = state.teams[target.team] || []; state.teams[target.team].push(name); }
  state.payments[name] = state.payments[name] || false;
  save();
}

/* ========== CREATE TEAMS FROM QUEUE ========== */
function createTeamsFromQueue(){
  while(state.playersQueue.length >= 5){
    const t = state.playersQueue.splice(0,5);
    state.teams.push(t);
    t.forEach(p=> state.payments[p] = state.payments[p] || false);
  }
  if(state.playersQueue.length > 0){
    const rem = state.playersQueue.splice(0, state.playersQueue.length);
    state.teams.push(rem);
    rem.forEach(p=> state.payments[p] = state.payments[p] || false);
  }
}

/* ========== BUTTONS & INTERACTIONS ========== */
btnAdd.addEventListener('click', ()=>{
  startEditing();
  const v = inputPlayer.value.trim(); if(!v) return;
  state.playersQueue.push(v); state.payments[v] = state.payments[v] || false; inputPlayer.value=''; renderAll();
});
inputPlayer.addEventListener('keydown', (e)=>{ if(e.key==='Enter') btnAdd.click(); });

// Sortear os 10 primeiros e formar A/B (sem afetar ordem do restante)
document.getElementById('btnFormTeams').addEventListener('click', ()=>{
  startEditing();
  if(state.playersQueue.length < 10){
    alert('Precisa ter ‚â•10 jogadores na fila para sortear os 10 primeiros.');
    return;
  }

  const first10 = state.playersQueue.slice(0,10);
  state.playersQueue = state.playersQueue.slice(10);
  shuffle(first10);
  const teamA = first10.slice(0,5);
  const teamB = first10.slice(5,10);
  state.teams.unshift(teamB);
  state.teams.unshift(teamA);
  teamA.concat(teamB).forEach(p => state.payments[p] = state.payments[p] || false);
  createTeamsFromQueue();
  renderAll();
});

document.getElementById('btnGroup5').addEventListener('click', ()=>{ startEditing(); createTeamsFromQueue(); renderAll(); });
document.getElementById('btnMakeNext').addEventListener('click', ()=>{ startEditing(); if(state.playersQueue.length < 5){ alert('Menos de 5 na fila.'); return; } const t = state.playersQueue.splice(0,5); state.teams.push(t); t.forEach(p=> state.payments[p] = state.payments[p] || false); renderAll(); });
document.getElementById('btnShuffle').addEventListener('click', ()=>{ startEditing(); if(confirm('Embaralhar fila?')){ shuffle(state.playersQueue); renderAll(); } });
document.getElementById('btnExport').addEventListener('click', ()=>{ const txt = state.playersQueue.join('\n'); navigator.clipboard.writeText(txt).then(()=> alert('Fila copiada para √°rea de transfer√™ncia')); });
document.getElementById('btnImport').addEventListener('click', ()=>{ startEditing(); const txt = prompt('Cole lista (um por linha):'); if(!txt) return; const arr = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean); state.playersQueue = state.playersQueue.concat(arr); arr.forEach(p=> state.payments[p] = state.payments[p] || false); renderAll(); });

// Nova Noite: limpar state and protect from immediate remote overwrite
document.getElementById('btnReset').addEventListener('click', ()=>{
  if(!confirm('Nova Noite: limpar dados (fila, times e pagamentos)?')) return;
  startEditing();
  firebasePause = true; // briefly ignore incoming remote while we push cleared state
  state.playersQueue=[]; state.teams=[]; state.payments={}; state.timerSeconds = 7*60;
  save(); renderAll();
  if(firebaseEnabled) pushStateToFirebaseImmediate();
  setTimeout(()=>{ firebasePause = false; }, 1500);
});

document.getElementById('btnKeepWinner').addEventListener('click', ()=>{ alert('O vencedor √© mantido automaticamente ‚Äî use "Time X perdeu" para mover o perdedor ao final.'); });

/* delegated handlers for queue */
queueList.addEventListener('click', (e)=>{ startEditing(); const t = e.target; if(t.matches('.edit-queue')){ const idx=+t.dataset.idx; const cur=state.playersQueue[idx]; const nv=prompt('Editar nome',cur); if(nv!==null && nv.trim()!==''){ state.playersQueue[idx]=nv.trim(); renderAll(); } }
  else if(t.matches('.up-queue')){ const idx=+t.dataset.idx; if(idx>0){ [state.playersQueue[idx-1],state.playersQueue[idx]]=[state.playersQueue[idx],state.playersQueue[idx-1]]; renderAll(); } }
  else if(t.matches('.down-queue')){ const idx=+t.dataset.idx; if(idx < state.playersQueue.length-1){ [state.playersQueue[idx+1],state.playersQueue[idx]]=[state.playersQueue[idx],state.playersQueue[idx+1]]; renderAll(); } }
  else if(t.matches('.move-to-team')){ const idx=+t.dataset.idx; promptMoveToTeamFromQueue(idx); }
  else if(t.matches('.remove-queue')){ const idx=+t.dataset.idx; if(confirm('Remover '+state.playersQueue[idx]+' da fila?')){ state.playersQueue.splice(idx,1); renderAll(); } } });

/* delegated handlers for teams & payments */
document.addEventListener('click', (e)=>{
  startEditing();
  const t = e.target;
  if(t.matches('.edit-team')){ const team=+t.dataset.team; const idx=+t.dataset.idx; const cur=state.teams[team][idx]; const nv=prompt('Editar nome',cur); if(nv!==null && nv.trim()!==''){ state.teams[team][idx]=nv.trim(); renderAll(); } }
  else if(t.matches('.move-up-team')){ const team=+t.dataset.team; const idx=+t.dataset.idx; if(idx>0){ let arr=state.teams[team]; [arr[idx-1],arr[idx]]=[arr[idx],arr[idx-1]]; renderAll(); } }
  else if(t.matches('.move-down-team')){ const team=+t.dataset.team; const idx=+t.dataset.idx; let arr=state.teams[team]; if(idx < arr.length-1){ [arr[idx+1],arr[idx]]=[arr[idx],arr[idx+1]]; renderAll(); } }
  else if(t.matches('.remove-team-player')){ const team=+t.dataset.team; const idx=+t.dataset.idx; const name=state.teams[team][idx]; if(confirm('Remover '+name+' do time e enviar para final da fila?')){ state.teams[team].splice(idx,1); state.playersQueue.push(name); renderAll(); } }
  else if(t.matches('.btn-pull-next')){ const team=+t.dataset.team; if(state.playersQueue.length<5){ alert('Menos de 5 na fila para formar um time.'); return; } const next=state.playersQueue.splice(0,5); state.teams[team]=state.teams[team].concat(next); next.forEach(p=> state.payments[p]=state.payments[p]||false); renderAll(); }
  else if(t.matches('.btn-loser')){ const team=+t.dataset.team; handleTeamLoss(team); }
  else if(t.matches('.move-player')){ const team=+t.dataset.team; const idx=+t.dataset.idx; promptMovePlayer(team, idx); }
  else if(t.matches('.btn-move-up-card')){ const team=+t.dataset.team; if(team>0){ const tmp = state.teams[team-1]; state.teams[team-1] = state.teams[team]; state.teams[team] = tmp; renderAll(); } }
  else if(t.matches('.btn-move-down-card')){ const team=+t.dataset.team; if(team < state.teams.length-1){ const tmp = state.teams[team+1]; state.teams[team+1] = state.teams[team]; state.teams[team] = tmp; renderAll(); } }
  else if(t.matches('.btn-move-to-pos')){ const team=+t.dataset.team; const posStr = prompt('Mover o time para qual posi√ß√£o? (1 = primeiro)'); if(posStr===null) return; const pos = Number(posStr); if(Number.isNaN(pos) || pos < 1 || pos > state.teams.length){ alert('Posi√ß√£o inv√°lida'); return;} const card = state.teams.splice(team,1)[0]; state.teams.splice(pos-1,0,card); renderAll(); }
});

/* helper functions omitted for brevity (they remain as in original file) */

function promptMoveToTeamFromQueue(queueIdx){
  if(state.teams.length===0){ alert('N√£o h√° times ainda. Forme um time primeiro.'); return; }
  const names = state.teams.map((t, i)=> `(${i}) Time ${String.fromCharCode(65+i)} ‚Äî ${t.length}/5`).join('\n');
  const resp = prompt('Escolha o time de destino digitando o n√∫mero entre par√™nteses:\n' + names);
  if(resp===null) return;
  const ti = Number(resp);
  if(Number.isNaN(ti) || ti<0 || ti>=state.teams.length){ alert('Time inv√°lido'); return; }
  const name = state.playersQueue.splice(queueIdx,1)[0];
  state.teams[ti].push(name);
  state.payments[name] = state.payments[name] || false;
  renderAll();
}

function promptMovePlayer(teamIdx, playerIdx){
  const names = ['Fila (digite -1)'].concat(state.teams.map((t,i)=> `(${i}) Time ${String.fromCharCode(65+i)} ‚Äî ${t.length}/5`));
  const resp = prompt('Mover para:\n' + names.join('\n') );
  if(resp===null) return;
  const v = Number(resp);
  const name = state.teams[teamIdx].splice(playerIdx,1)[0];
  if(v === -1){ state.playersQueue.push(name); }
  else if(!Number.isNaN(v) && v>=0 && v<state.teams.length){ state.teams[v].push(name); }
  else { alert('Destino inv√°lido'); state.teams[teamIdx].splice(playerIdx,0,name); } // rollback
  renderAll();
}

/* handle team loss and reassign players */
function handleTeamLoss(teamIndex){
  if(teamIndex<0||teamIndex>=state.teams.length) return;
  const losing = state.teams.splice(teamIndex,1)[0];
  let i = state.teams.findIndex(t => t.length < 5);
  while(i !== -1 && losing.length > 0){
    const need = 5 - state.teams[i].length;
    const take = losing.splice(0, need);
    state.teams[i].push(...take);
    i = state.teams.findIndex((t, idx) => t.length < 5 && idx > i);
  }
  while(losing.length >= 5){
    const t = losing.splice(0,5);
    state.teams.push(t);
  }
  if(losing.length > 0) state.teams.push(losing);
  state.teams.flat().forEach(p=> state.payments[p] = state.payments[p] || false);
  renderAll();
}

/* payments */
function renderPayments(){
  paymentsList.innerHTML = '';
  const players = uniquePlayers();
  if(players.length === 0){ paymentsList.innerHTML = '<div class="small">Nenhum jogador</div>'; return; }
  players.forEach(name=>{
    const checked = state.payments[name] ? 'checked' : '';
    const row = document.createElement('div');
    row.innerHTML = `<label style="display:flex;align-items:center;gap:8px"><input type="checkbox" class="chk-paid" data-name="${escapeAttr(name)}" ${checked}> <span>${escape(name)}</span></label>`;
    paymentsList.appendChild(row);
  });
}

paymentsList.addEventListener('change', (e)=>{
  if(e.target && e.target.classList && e.target.classList.contains('chk-paid')){
    const name = e.target.dataset.name; state.payments[name] = e.target.checked; save();
  }
});

document.getElementById('btnClearPayments').addEventListener('click', ()=>{ if(!confirm('Limpar todas as marca√ß√µes de pagamento?')) return; state.payments={}; renderAll(); });
document.getElementById('btnExportPayments').addEventListener('click', ()=>{ const rows = uniquePlayers().map(n=> `${n}\t${state.payments[n] ? 'Pago' : 'Nao pago'}`); navigator.clipboard.writeText(rows.join('\n')).then(()=>alert('Exportado')); });

/* drag end cleanup */
queueList.addEventListener('dragover', (e)=> e.preventDefault());
document.addEventListener('dragend', ()=> { currentDrag = null; clearDragOver(); });

/* ========== TIMER & APITO (FINAL WHISTLE FROM LICENSED FILE) ==========
   - Testar Apito and Apito Final now play only the licensed file (finalWhistle element).
   - When timer ends, we play finalWhistle automatically (if chkFinalWhistle is checked and sound is enabled).
*/
let timerInterval = null;
document.getElementById('startBtn').addEventListener('click', ()=>{
  if(timerInterval) return;
  timerInterval = setInterval(()=>{
    if(state.timerSeconds>0){ state.timerSeconds--; timerDisplay.textContent = formatTime(state.timerSeconds); save(); }
    else { clearInterval(timerInterval); timerInterval=null; setTimeout(()=> onTimerEndPrompt(),420); }
  },1000);
});
document.getElementById('pauseBtn').addEventListener('click', ()=>{ if(timerInterval){ clearInterval(timerInterval); timerInterval=null; } });
document.getElementById('resetBtnTimer').addEventListener('click', ()=>{ if(timerInterval){ clearInterval(timerInterval); timerInterval=null; } state.timerSeconds=7*60; timerDisplay.textContent = formatTime(state.timerSeconds); save(); });
document.getElementById('chkSound').addEventListener('change', (e)=>{ state.soundOn = e.target.checked; save(); });

// We keep an AudioContext only to satisfy mobile autoplay resume if needed, but the actual sound is played from the audio element.
let audioCtx = null;
function ensureAudioContext(){ if(!audioCtx){ try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }catch(e){ audioCtx = null; } } }

/* playWhistle (synth) is left in the file as fallback but will NOT be used by Testar Apito or timer end. */

function playWhistle(){
  try{
    ensureAudioContext();
    if(!audioCtx) return;
    const now = audioCtx.currentTime;
    const burstDur = 1.2;
    const gap = 0.35;
    function scheduleBurst(offset, freqStart, gainPeak){
      const start = now + offset;
      const bufferSize = Math.floor(audioCtx.sampleRate * burstDur);
      const noiseBuf = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = noiseBuf.getChannelData(0);
      for (let i=0;i<bufferSize;i++){
        data[i] = (Math.random()*2 - 1) * Math.pow(1 - i/bufferSize, 0.9) * (0.95 + 0.05*Math.sin(i/80));
      }
      const noise = audioCtx.createBufferSource(); noise.buffer = noiseBuf;
      const bp = audioCtx.createBiquadFilter(); bp.type = 'bandpass';
      bp.frequency.setValueAtTime(freqStart, start);
      bp.frequency.exponentialRampToValueAtTime(900, start + burstDur * 0.85);
      bp.Q.value = 8;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, start);
      g.gain.exponentialRampToValueAtTime(gainPeak, start + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, start + burstDur);
      const osc = audioCtx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(freqStart * 1.02, start);
      const og = audioCtx.createGain();
      og.gain.setValueAtTime(0.0001, start);
      og.gain.exponentialRampToValueAtTime(0.12, start + 0.03);
      og.gain.exponentialRampToValueAtTime(0.0001, start + burstDur);
      noise.connect(bp);
      bp.connect(g);
      g.connect(audioCtx.destination);
      osc.connect(og);
      og.connect(audioCtx.destination);
      noise.start(start);
      noise.stop(start + burstDur + 0.02);
      osc.start(start);
      osc.stop(start + burstDur + 0.02);
    }
    scheduleBurst(0, 2600, 1.3);
    scheduleBurst(gap, 2200, 1.1);
  }catch(e){ console.warn('Erro ao tocar apito (synth):', e); }
}

/* NEW: final long loud whistle ‚Äî play ONLY licensed audio element */
function playFinalWhistle(){
  try{
    // Resume audio context if it exists (helps some mobile browsers)
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
    const audioEl = document.getElementById('finalWhistle');
    if(!audioEl) return;
    // Ensure source is the licensed drive link (in case someone changed it)
    // NOTE: if you later put the file in /assets, update this src accordingly.
    audioEl.pause();
    audioEl.currentTime = 0;
    audioEl.play().catch(e=> console.warn('Erro ao reproduzir audio finalWhistle:', e));
    console.info('playFinalWhistle triggered (licensed file)');
  }catch(e){ console.warn('Erro ao tocar apito final:', e); }
}

/* Button handlers: Test and Final now call playFinalWhistle only */
document.getElementById('btnTestWhistle').addEventListener('click', async (ev)=>{
  try{
    ensureAudioContext();
    if(audioCtx && audioCtx.state === 'suspended') await audioCtx.resume();
    playFinalWhistle();
  }catch(e){ console.warn(e); }
});

document.getElementById('btnFinalWhistle').addEventListener('click', async (ev)=>{
  try{
    ensureAudioContext();
    if(audioCtx && audioCtx.state === 'suspended') await audioCtx.resume();
    playFinalWhistle();
  }catch(e){ console.warn(e); }
});

/* onTimerEndPrompt: when timer ends, only trigger the licensed final whistle if chkFinalWhistle is checked and sound is enabled */
function onTimerEndPrompt(){
  if(state.teams.length<2){
    alert('Tempo acabou ‚Äî n√£o h√° teams suficientes para registrar derrota.');
    return;
  }
  try{
    const useFinal = document.getElementById('chkFinalWhistle') ? document.getElementById('chkFinalWhistle').checked : true;
    if(state.soundOn && useFinal){
      // Try to resume audio context first (improves mobile behavior if user already interacted)
      try{ ensureAudioContext(); if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{}); }catch(e){}
      playFinalWhistle();
    }
  }catch(e){
    console.warn('Erro ao decidir apito:', e);
  }

  if(confirm('Tempo encerrado. Registrar derrota do time da frente (Time 1)? OK = Time 1 perdeu, Cancelar = Time 2 perdeu')){
    handleTeamLoss(0);
  } else {
    handleTeamLoss(1);
  }
}

/* ========== INIT & LOAD ========== */
window.addEventListener('load', ()=>{
  load();
  renderAll();
  try{ if(ENABLE_FIREBASE && enableFirebaseIfConfigured()){ console.log('Firebase enabled'); } }catch(e){ console.warn(e); }
  setInterval(save,2000);
  // connect user interactions to editing/lock behavior
  ['click','keydown','input','dragstart'].forEach(ev=>{
    document.addEventListener(ev, ()=> startEditing(), {capture:true, passive:true});
  });
  window.addEventListener('beforeunload', ()=> { stopEditing(); });
  window.futpro = { state, renderAll, performMove, clientId };
});
</script>
</body>
</html>
